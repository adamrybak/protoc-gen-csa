use super::{generator_model::GeneratorModel, property::PropertyFormat, TypeMap};
use crate::{
    generator::BaseType,
    google::protobuf::{
        compiler::{code_generator_response, CodeGeneratorResponse},
        DescriptorProto, FieldDescriptorProto, FileDescriptorProto,
    },
    utility::IndentLines,
};
use convert_case::{Case, Casing};
use indoc::formatdoc;
use std::path::Path;

pub struct GeneratorPartial<'a> {
    response: &'a mut CodeGeneratorResponse,
    type_map: &'a TypeMap,
    file: &'a FileDescriptorProto,
    file_name: String,
    partial_namespace: String,
    model_namespace: String,
}

impl<'a> GeneratorPartial<'a> {
    pub fn generate(response: &'a mut CodeGeneratorResponse, type_map: &'a TypeMap, file: &'a FileDescriptorProto) {
        let file_name = Self::file_name(file);
        let partial_namespace = Self::namespace(file);
        let model_namespace = GeneratorModel::namespace(file);
        let this = GeneratorPartial {
            response,
            type_map,
            file,
            file_name,
            partial_namespace,
            model_namespace,
        };
        let content = this.write_content();
        this.response.file.push(code_generator_response::File {
            name: Some(this.file_name),
            content: Some(content),
            insertion_point: None,
            generated_code_info: None,
        });
    }

    pub fn file_name(file: &FileDescriptorProto) -> String {
        Path::new(&file.name().to_case(Case::Pascal)).with_extension("Partials.cs").to_string_lossy().to_string()
    }

    pub fn namespace(file: &FileDescriptorProto) -> String {
        let csharp_namespace = file.options.as_ref().and_then(|o| Some(o.csharp_namespace().to_string()));
        if let Some(csharp_namespace) = csharp_namespace {
            csharp_namespace
        } else {
            file.package().split('.').map(|p| p.to_case(Case::Pascal)).collect::<Vec<_>>().join(".")
        }
    }

    fn write_content(&self) -> String {
        [
            self.write_header(), //
            self.write_classes(),
        ]
        .into_iter()
        .filter(|x| !x.is_empty())
        .collect::<Vec<_>>()
        .join("\n\n")
    }

    fn write_header(&self) -> String {
        let input_file_name = &self.file.name();
        let partial_namespace = &self.partial_namespace;
        formatdoc!(
            r#"
            //----------------------------------------------------------------------------------------------------
            // <auto-generated>
            //     Generated by the protoc-gen-csa tool.
            //     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
            //     Source: {input_file_name}
            // </auto-generated>
            //----------------------------------------------------------------------------------------------------
            #nullable enable

            namespace {partial_namespace};"#
        )
    }

    fn write_classes(&self) -> String {
        self.file.message_type.iter().map(|m| self.write_class(m)).filter(|x| !x.is_empty()).collect::<Vec<_>>().join("\n\n")
    }

    fn write_class(&self, message_type: &DescriptorProto) -> String {
        let model_namespace = &self.model_namespace;
        let class_name = message_type.name().to_case(Case::Pascal);
        let to_model = self.write_to_model(message_type);
        let regions = [to_model].into_iter().filter(|x| !x.is_empty()).collect::<Vec<_>>().join("\n\n").indent_subsequent_lines(1);
        formatdoc!(
            r#"
            public partial class {class_name} : CsaCommon.IModelable<{model_namespace}.{class_name}>
            {{
                {regions}
            }}"#,
        )
    }

    fn write_to_model(&self, message_type: &DescriptorProto) -> String {
        let model_namespace = &self.model_namespace;
        let class_name = message_type.name().to_case(Case::Pascal);
        let header = formatdoc!(
            r#"
            public {model_namespace}.{class_name} ToModel(string? propertyPath = null)
            {{
                var model = new {model_namespace}.{class_name}();"#
        );
        let assignments = self.write_assignments(message_type).indent_lines(1);
        let footer = formatdoc!(
            r#"
                return model;
            }}"#
        );
        [header, assignments, footer].into_iter().filter(|x| !x.is_empty()).collect::<Vec<_>>().join("\n")
    }

    fn write_assignments(&self, message_type: &DescriptorProto) -> String {
        let assignments = message_type.field.iter().map(|f| self.write_assignment(f)).filter(|(a, _)| !a.is_empty()).collect::<Vec<_>>();
        let has_validations = assignments.iter().any(|(_, v)| *v);
        let assignments = assignments.into_iter().map(|(a, _)| a).collect::<Vec<_>>().join("\n");

        if has_validations {
            formatdoc!(
                r#"
                var invalid = new CsaCommon.InvalidArgumentsException();
                {assignments}
                if (invalid.HasErrors) throw invalid;"#
            )
        } else {
            assignments
        }
    }

    fn write_assignment(&self, field: &FieldDescriptorProto) -> (String, bool) {
        let property = self.type_map.property(field);
        let property_name = property.name();
        let nullable = property.nullable().then(|| "Nullable").unwrap_or_default();
        let decode_unchecked = match (property.base_type(), &property.options().format) {
            (BaseType::Long, PropertyFormat::UnixTimeSeconds) => Some("DecodeSeconds"),
            (BaseType::Long, PropertyFormat::UnixTimeMilliseconds) => Some("DecodeMilliseconds"),
            _ => None,
        };
        let decode_checked = match (property.base_type(), &property.options().format) {
            (BaseType::String, PropertyFormat::Guid) => Some(format!("Decode{nullable}Guid")),
            (BaseType::String, PropertyFormat::DateTime) => Some(format!("Decode{nullable}DateTime")),
            (BaseType::String, PropertyFormat::DateTimeOffset) => Some(format!("Decode{nullable}DateTimeOffset")),
            (BaseType::String, PropertyFormat::DateOnly) => Some(format!("Decode{nullable}DateOnly")),
            (BaseType::String, PropertyFormat::TimeOnly) => Some(format!("Decode{nullable}TimeOnly")),
            (BaseType::String, PropertyFormat::TimeSpan) => Some(format!("Decode{nullable}TimeSpan")),
            _ => None,
        };
        if !property.repeated() {
            let (value, has_validation) = match (decode_unchecked, decode_checked) {
                (Some(f), _) => (format!("CsaCommon.Decoder.{f}({property_name})"), false),
                (_, Some(f)) => (format!("CsaCommon.Decoder.{f}(propertyPath, nameof({property_name}), {property_name}, invalid)"), true),
                _ => (format!("{property_name}"), false),
            };
            (format!("model.{property_name} = {value};"), has_validation)
        } else {
            let (enumerable, has_validation) = match (decode_unchecked, decode_checked) {
                (Some(f), _) => (format!(r#"{property_name}.Select(CsaCommon.Decoder.{f})"#), false),
                (_, Some(f)) => (
                    format!(r#"{property_name}.Select((x, i) => CsaCommon.Decoder.{f}(propertyPath, $"{{nameof({property_name})}}[{{i}}]", x, invalid))"#),
                    true,
                ),
                _ => (format!("{property_name}"), false),
            };
            (format!("model.{property_name}.AddRange({enumerable});"), has_validation)
        }
    }
}
