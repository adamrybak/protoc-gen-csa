use super::TypeMap;
use crate::google::protobuf::{
    compiler::{code_generator_response, CodeGeneratorResponse},
    FileDescriptorProto,
};
use convert_case::{Case, Casing};
use indoc::formatdoc;
use std::path::Path;

pub struct GeneratorPartial<'a> {
    response: &'a mut CodeGeneratorResponse,
    type_map: &'a TypeMap,
    file: &'a FileDescriptorProto,
    file_name: String,
}

impl<'a> GeneratorPartial<'a> {
    pub fn generate(response: &mut CodeGeneratorResponse, type_map: &TypeMap, file: &FileDescriptorProto) {
        let file_name = Self::file_name(file);
        let this = GeneratorPartial { response, type_map, file, file_name };

        let content = this.write_content();
        this.response.file.push(code_generator_response::File {
            name: Some(this.file_name),
            content: Some(content),
            insertion_point: None,
            generated_code_info: None,
        });
    }

    pub fn file_name(file: &FileDescriptorProto) -> String {
        Path::new(&file.name().to_case(Case::Pascal)).with_extension("Partial.cs").to_string_lossy().to_string()
    }

    fn write_content(&self) -> String {
        let header = self.write_header();
        [header].join("\n\n")
    }

    fn write_header(&self) -> String {
        let input_file_name = &self.file.name();
        let namespace = TypeMap::namespace(&self.file);
        formatdoc!(
            r#"
            //----------------------------------------------------------------------------------------------------
            // <auto-generated>
            //     Generated by the protoc-gen-csa tool.
            //     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
            //     Source: {input_file_name}
            // </auto-generated>
            //----------------------------------------------------------------------------------------------------
            
            namespace {namespace};"#
        )
    }
}
