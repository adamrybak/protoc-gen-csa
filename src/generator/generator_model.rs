use super::{GeneratorPartial, TypeMap};
use crate::{
    google::protobuf::{
        compiler::{code_generator_response, CodeGeneratorResponse},
        DescriptorProto, FieldDescriptorProto, FileDescriptorProto,
    },
    utility::{IndentLines, JoinNonEmpty},
};
use convert_case::{Case, Casing};
use indoc::formatdoc;
use std::path::Path;

pub struct GeneratorModel<'a> {
    response: &'a mut CodeGeneratorResponse,
    type_map: &'a TypeMap,
    file: &'a FileDescriptorProto,
    file_name: String,
    partial_namespace: String,
    model_namespace: String,
}

impl<'a> GeneratorModel<'a> {
    pub fn generate(response: &'a mut CodeGeneratorResponse, type_map: &'a TypeMap, file: &'a FileDescriptorProto) {
        let file_name = Self::file_name(file);
        let partial_namespace = GeneratorPartial::namespace(file);
        let model_namespace = Self::namespace(file);
        let this = GeneratorModel {
            response,
            type_map,
            file,
            file_name,
            partial_namespace,
            model_namespace,
        };
        let content = this.write_content();
        this.response.file.push(code_generator_response::File {
            name: Some(this.file_name),
            content: Some(content),
            insertion_point: None,
            generated_code_info: None,
        });
    }

    pub fn file_name(file: &FileDescriptorProto) -> String {
        Path::new(&file.name().to_case(Case::Pascal)).with_extension("Models.cs").to_string_lossy().to_string()
    }

    pub fn namespace(file: &FileDescriptorProto) -> String {
        format!("{}.Models", GeneratorPartial::namespace(file))
    }

    fn write_content(&self) -> String {
        [self.write_header(), self.write_classes()].into_iter().join_non_empty("\n\n")
    }

    fn write_header(&self) -> String {
        let input_file_name = &self.file.name();
        let model_namespace = &self.model_namespace;
        formatdoc!(
            r#"
            //----------------------------------------------------------------------------------------------------
            // <auto-generated>
            //     Generated by the protoc-gen-csa tool.
            //     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
            //     Source: {input_file_name}
            // </auto-generated>
            //----------------------------------------------------------------------------------------------------
            #nullable enable

            namespace {model_namespace};"#
        )
    }

    fn write_classes(&self) -> String {
        self.file.message_type.iter().map(|m| self.write_class(m)).join_non_empty("\n\n")
    }

    fn write_class(&self, message_type: &DescriptorProto) -> String {
        let partial_namespace = &self.partial_namespace;
        let class_name = message_type.name().to_case(Case::Pascal);
        let properties = self.write_properties(message_type);
        let to_message = self.write_to_message(message_type);
        let validations = self.write_validations(message_type);
        [
            formatdoc!(
                r#"
                public partial class {class_name} : CsaCommon.IMessageable<{partial_namespace}.{class_name}>
                {{"#
            ),
            [properties, to_message, validations].into_iter().join_non_empty("\n\n").indent_lines(1),
            formatdoc!(
                r#"
                }}"#
            ),
        ]
        .into_iter()
        .join_non_empty("\n")
    }

    fn write_properties(&self, message_type: &DescriptorProto) -> String {
        message_type.field.iter().map(|f| self.write_property(f)).join_non_empty("\n")
    }

    fn write_property(&self, field: &FieldDescriptorProto) -> String {
        let property = self.type_map.property(field);
        let property_type = property.full_type_name(&self.model_namespace);
        let property_name = property.name();
        let default_value = property.default_value().map(|x| format!(" = {};", x)).unwrap_or_default();
        format!(r#"public {property_type} {property_name} {{ get; set; }}{default_value}"#)
    }

    fn write_to_message(&self, message_type: &DescriptorProto) -> String {
        let partial_namespace = &self.partial_namespace;
        let class_name = message_type.name().to_case(Case::Pascal);
        let assignments = self.write_assignments(message_type);
        [
            formatdoc!(
                r#"
                public {partial_namespace}.{class_name} ToMessage()
                {{
                    var msg = new {partial_namespace}.{class_name}();"#
            ),
            assignments.indent_lines(1),
            formatdoc!(
                r#"
                    return msg;
                }}"#
            ),
        ]
        .into_iter()
        .join_non_empty("\n")
    }

    fn write_assignments(&self, message_type: &DescriptorProto) -> String {
        message_type.field.iter().map(|f| self.write_assignment(f)).join_non_empty("\n")
    }

    fn write_assignment(&self, field: &FieldDescriptorProto) -> String {
        let property = self.type_map.property(field);
        let property_name = property.name();
        match (property.repeated(), property.codec()) {
            (false, None) => format!(r#"msg.{property_name} = {property_name};"#),
            (false, Some(codec)) => format!(r#"msg.{property_name} = CsaCommon.{codec}.Encode({property_name});"#),
            (true, None) => format!(r#"msg.{property_name}.AddRange({property_name});"#),
            (true, Some(codec)) => format!(r#"msg.{property_name}.AddRange({property_name}.Select(CsaCommon.{codec}.Encode));"#),
        }
    }

    fn write_validations(&self, message_type: &DescriptorProto) -> String {
        let partial_namespace = &self.partial_namespace;
        let class_name = message_type.name().to_case(Case::Pascal);
        [formatdoc!(
            r#"
            partial void Validate(string? propertyPath = null);

            void CsaCommon.IMessageable<{partial_namespace}.{class_name}>.Validate(string? propertyPath)
            {{
                Validate(propertyPath);
            }}"#,
        )]
        .into_iter()
        .join_non_empty("\n")
    }
}
